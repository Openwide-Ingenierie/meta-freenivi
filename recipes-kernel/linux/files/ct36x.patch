diff --git a/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi b/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi
index 46f6fc4..d4a7515 100644
--- a/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi
@@ -461,6 +461,18 @@
                 wakeup-gpios = <&gpio1 9 0>;
         };
 
+        ct36x_ts@01 {
+                compatible = "ct36x_ts,ct36x_ts";
+                reg = <0x01>;
+                ct-model = <363>;
+                touch-gpio = <&gpio1 9 0>;
+                reset-gpio = <&gpio2 0 GPIO_ACTIVE_HIGH>;
+                max-x = <1024>;
+                max-y = <768>;
+                orientation = <1 0 0 1>; 
+        };
+
+
         ft5x06_ts@38 {
 		compatible = "ft5x06-ts,ft5x06-ts";
 		reg = <0x38>;
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d9ea01f..7f74e21 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -11,6 +11,9 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+config CT36X_TS
+	tristate "CT36X touchscreens support"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index f76960f..96b6acf 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -6,6 +6,7 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+obj-y					+= ct36x/
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
diff --git a/drivers/input/touchscreen/ct36x/Kconfig b/drivers/input/touchscreen/ct36x/Kconfig
new file mode 100644
index 0000000..335cff4
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/Kconfig
@@ -0,0 +1,13 @@
+#
+# Adc hardware configuration
+#
+
+config CT360_TS
+	tristate "ct360"
+
+config CT361_TS
+	tristate "ct361"
+
+config CT363_TS
+	tristate "ct363"
+
diff --git a/drivers/input/touchscreen/ct36x/Makefile b/drivers/input/touchscreen/ct36x/Makefile
new file mode 100644
index 0000000..bcebcb0
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_CT36X_TS)		+= ct36x_ts.o
diff --git a/drivers/input/touchscreen/ct36x/core.c b/drivers/input/touchscreen/ct36x/core.c
new file mode 100644
index 0000000..28660fd
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/core.c
@@ -0,0 +1,153 @@
+#include "ct36x_priv.h"
+
+int ct36x_chip_set_idle(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char buf[2] = {0x00, 0xA5};
+
+    ret = ct36x_update_write(ts, 0x7F, buf, 2);
+    mdelay(10);
+
+    return ret;
+}
+
+static int ct36x_chip_rst_offset(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char buf = 0x00;
+
+    ret =ct36x_update_write(ts, 0x7F, &buf, 1);
+    mdelay(10);
+
+    return ret;
+}
+
+static char ct36x_chip_get_bus_status(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char buf;
+
+    ret =ct36x_update_read(ts, 0x7F, &buf, 1);
+    mdelay(10);
+
+    return (ret < 0)?-1:buf;
+}
+
+static int ct36x_chip_era_flash(struct ct36x_data *ts)
+{
+    char c;
+    int ret = 0;
+    char buf[3] = {0x00, 0x33, 0x00};
+
+    ret = ct36x_update_write(ts, 0x7F, buf, 3);
+    mdelay(10);
+
+    // Reset I2C offset address
+    ret = ct36x_chip_rst_offset(ts);
+    if(ret < 0){
+        dev_err(ts->dev, "CT36X chip: Failed to reset I2C offset address\n");
+        return ret;
+    }
+
+    // Read I2C bus status
+    c = ct36x_chip_get_bus_status(ts);
+    if ( c != 0xAA ) {
+        dev_err(ts->dev, "CT36X chip: Failed to get bus status: %d\n", c);
+        return -1;
+    }
+
+    return 0;
+}
+
+int ct36x_chip_get_ver(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char buf[3], ver;
+
+    // Read version command
+    buf[0] = 0xFF;
+    buf[1] = 0x3F;
+    buf[2] = 0xFF;
+    ret = ct36x_write(ts, buf, 3);
+    if(ret < 0)
+        return ret;
+    mdelay(10);
+
+    buf[0] = 0x00;
+    ret = ct36x_write(ts, buf, 1);
+    if(ret < 0)
+        return ret;
+    mdelay(10);
+
+    // do read version
+    ret = ct36x_read(ts, &ver, 1);
+    if(ret < 0)
+        return ret;
+    mdelay(10);
+
+    return ver;
+}
+
+int ct36x_chip_get_vendor(struct ct36x_data *ts)
+{
+    return 0;
+}
+
+int ct36x_chip_go_sleep(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char buf[3];
+
+    buf[0] = 0xFF;
+    buf[1] = 0x8F;
+    buf[2] = 0xFF;
+    ret = ct36x_write(ts, buf, 3);
+    if(ret < 0)
+        return ret;
+    mdelay(3);
+
+    buf[0] = 0x00;
+    buf[1] = 0xAF;
+    ret = ct36x_write(ts, buf, 2);
+    if(ret < 0)
+        return ret;
+    mdelay(3);
+
+    return 0;
+}
+
+int ct36x_chip_go_bootloader(struct ct36x_data *ts)
+{
+    int ret = 0;
+    char  c;
+
+    // Init bootloader
+    ret = ct36x_chip_set_idle(ts);
+    if(ret < 0){
+        dev_err(ts->dev, "CT36X chip: Failed to set idle\n");
+        return ret;
+    }
+
+    // Reset I2C offset address
+    ret = ct36x_chip_rst_offset(ts);
+    if(ret < 0){
+        dev_err(ts->dev, "CT36X chip: Failed to reset I2C offset address\n");
+        return ret;
+    }
+
+    // Get I2C bus status
+    c = ct36x_chip_get_bus_status(ts);
+    if ( c != 0xAA ) {
+        dev_err(ts->dev, "CT36X chip: Failed to get bus status: %d\n", c);
+        return -1;
+    }
+
+    // Erase flash
+    ret = ct36x_chip_era_flash(ts);
+    if ( ret < 0 ) {
+        dev_err(ts->dev, "CT36X chip: Failed to era flash\n");
+        return ret;
+    }
+
+    return 0;
+}
diff --git a/drivers/input/touchscreen/ct36x/ct360.c b/drivers/input/touchscreen/ct36x/ct360.c
new file mode 100644
index 0000000..e6f8952
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/ct360.c
@@ -0,0 +1,3 @@
+
+struct ct36x_ops ct360_ops = {
+};
diff --git a/drivers/input/touchscreen/ct36x/ct363.c b/drivers/input/touchscreen/ct36x/ct363.c
new file mode 100644
index 0000000..ff97814
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/ct363.c
@@ -0,0 +1,186 @@
+#define CT363_POINT_NUM		10
+
+struct ct363_finger_data {
+    unsigned char	xhi;			// X coordinate Hi
+    unsigned char	yhi;			// Y coordinate Hi
+    unsigned char	ylo : 4;		// Y coordinate Lo
+    unsigned char	xlo : 4;		// X coordinate Lo
+    unsigned char   status : 3;     // Action information, 1: Down; 2: Move; 3: Up
+    unsigned char   id : 5;         // ID information, from 1 to CFG_MAX_POINT_NUM
+    unsigned char	area;			// Touch area
+    unsigned char	pressure;		// Touch Pressure
+};
+
+
+struct ct363_priv{
+    int press;
+    int release;
+    int x, y;
+    union{
+        struct ct363_finger_data pts[CT363_POINT_NUM];
+        char buf[CT363_POINT_NUM * sizeof(struct ct363_finger_data)];
+    };
+};
+
+static int ct363_init_hw(struct ct36x_data *ts)
+{
+    gpio_direction_input(ts->irq_io.gpio);
+    gpio_direction_output(ts->rst_io.gpio, ts->rst_io.active_low);
+
+    return 0;
+}
+static void ct363_deinit_hw(struct ct36x_data *ts)
+{
+    gpio_free(ts->rst_io.gpio);
+    gpio_free(ts->irq_io.gpio);
+}
+
+static void ct363_reset_hw(struct ct36x_data *ts)
+{
+    gpio_direction_output(ts->rst_io.gpio, ts->rst_io.active_low);
+    msleep(50);
+    gpio_set_value(ts->rst_io.gpio, !ts->rst_io.active_low);
+    msleep(50);
+    gpio_set_value(ts->rst_io.gpio, ts->rst_io.active_low);
+    msleep(500);
+}
+
+static int ct363_init(struct ct36x_data *ts)
+{
+    int ret = 0;
+    struct ct363_priv *ct363 = NULL;
+
+    ret = ct363_init_hw(ts);
+    if(ret < 0)
+        return ret;
+
+    /* Hardware reset */
+    ct363_reset_hw(ts);
+    msleep(5);
+
+    ts->point_num = CT363_POINT_NUM;
+
+    ct363 = kzalloc(sizeof(struct ct363_priv), GFP_KERNEL);
+    if(!ct363){
+        dev_err(ts->dev, "No memory for ct36x");
+        return -ENOMEM;
+    }
+    ts->priv = ct363;
+
+    return 0;
+}
+
+static void ct363_deinit(struct ct36x_data *ts)
+{
+    struct ct363_priv *ct363 = ts->priv;
+
+    ct363_deinit_hw(ts);
+    kfree(ct363);
+    ts->priv = NULL;
+
+    return;
+}
+
+static int ct363_suspend(struct ct36x_data *ts)
+{
+    int ret = 0;
+
+    ret = ct36x_chip_go_sleep(ts);
+
+    if(ret < 0)
+        dev_warn(ts->dev, "CT363 chip: failed to go to sleep\n");
+    return ret;
+}
+
+static int ct363_resume(struct ct36x_data *ts)
+{
+    int i;
+
+    /* Hardware reset */
+    ct363_reset_hw(ts);
+    msleep(3);
+
+    for(i = 0; i < ts->point_num; i++){
+        input_mt_slot(ts->input, i);
+        input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, false);
+    }
+    input_sync(ts->input);
+
+    return 0;
+}
+
+static void ct363_report(struct ct36x_data *ts)
+{
+    int t;
+    int i, ret = 0;
+    int sync = 0, x, y;
+    int len = sizeof(struct ct363_finger_data) * ts->point_num;
+    struct ct363_priv *ct363 = ts->priv;
+
+    ret = ct36x_read(ts, ct363->buf, len);
+    if(ret < 0){
+        dev_warn(ts->dev, "Failed to read finger data\n");
+        return;
+    }
+
+    if(ct36x_dbg_level==2) {
+        ct36x_dbg(ts, "CT363buf[%d]: ", t);
+        ct36x_dbg(ts, "0x%x\t0x%x\t0x%x\t0x%x\t0x%x\t0x%x\t0x%x\t0x%x ",
+                ct363->pts[t].xhi,
+                ct363->pts[t].xlo,
+                ct363->pts[t].yhi,
+                ct363->pts[t].ylo,
+                ct363->pts[t].status,
+                ct363->pts[t].id,
+                ct363->pts[t].area,
+                ct363->pts[t].pressure);
+    }
+
+    ct363->press = 0;
+    for(i = 0; i < ts->point_num; i++) {
+        if((ct363->pts[i].xhi != 0xFF && ct363->pts[i].yhi != 0xFF) &&
+                (ct363->pts[i].status == 1 || ct363->pts[i].status == 2)) {
+            x = (ct363->pts[i].xhi<<4)|(ct363->pts[i].xlo&0xF);
+            y = (ct363->pts[i].yhi<<4)|(ct363->pts[i].ylo&0xF);
+
+            ct363->x = ts->orientation[0] * x + ts->orientation[1] * y;
+            ct363->y = ts->orientation[2] * x + ts->orientation[3] * y;
+
+            if( (ct363->x > ts->x_max) || (ct363->y > ts->y_max) || (ct363->x < 0) || (ct363->y < 0) ){
+                continue ;
+            }
+            input_mt_slot(ts->input, ct363->pts[i].id - 1);
+            input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
+            input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, 1);
+            input_report_abs(ts->input, ABS_MT_POSITION_X, ct363->x);
+            input_report_abs(ts->input, ABS_MT_POSITION_Y, ct363->y);
+            input_report_abs(ts->input, ABS_MT_PRESSURE, ct363->pts[i].pressure);
+            ct36x_dbg(ts, "CT363 report value: id: %d,  x: %d, y:%d\n",ct363->pts[i].id - 1, ct363->x, ct363->y);
+
+            sync = 1;
+            ct363->press |= 0x01 << (ct363->pts[i].id - 1);
+        }
+    }
+    ct363->release &= ct363->release ^ ct363->press;
+    for(i = 0; i < ts->point_num; i++){
+        if ( ct363->release & (0x01<<i) ) {
+            input_mt_slot(ts->input, i);
+            input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, false);
+            ct36x_dbg(ts, "CT363 release\n");
+            sync = 1;
+        }
+    }
+    ct363->release = ct363->press;
+
+    if(sync)
+        input_sync(ts->input);
+
+    return;
+}
+struct ct36x_ops ct363_ops = {
+    .init = ct363_init,
+    .deinit = ct363_deinit,
+    .suspend = ct363_suspend,
+    .resume = ct363_resume,
+    .report = ct363_report,
+};
diff --git a/drivers/input/touchscreen/ct36x/ct36x_priv.h b/drivers/input/touchscreen/ct36x/ct36x_priv.h
new file mode 100644
index 0000000..1491057
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/ct36x_priv.h
@@ -0,0 +1,150 @@
+#ifndef __CT36X_PRIV__
+#define __CT36X_PRIV__
+
+//#include <linux/earlysuspend.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/input/mt.h>
+#include <linux/ct36x.h>
+
+#include "../tp_suspend.h"
+
+int flag_ct36x_model;
+
+int ct36x_dbg_level = 0;
+module_param_named(dbg_level, ct36x_dbg_level, int, 0644);
+#if 1
+#define ct36x_dbg(ts, format, arg...)            \
+	do { \
+		if (ct36x_dbg_level) { \
+			dev_printk(KERN_INFO , ts->dev , format , ## arg) ;\
+		} \
+	} while (0)
+#else 
+#define DBG(x...)
+#endif
+
+
+
+
+#define CT36X_I2C_RATE	(200 * 1000)
+struct ct36x_data;
+
+struct ct36x_ops{
+	int (*init)(struct ct36x_data *);
+	void (*deinit)(struct ct36x_data *);
+	int (*suspend)(struct ct36x_data *);
+	int (*resume)(struct ct36x_data *);
+	void (*report)(struct ct36x_data *);
+};
+struct ct36x_data{
+	int irq;
+	int model;
+	int x_max;
+	int y_max;
+	int orientation[4];
+	int point_num;
+
+	struct ct36x_gpio rst_io;
+	struct ct36x_gpio irq_io;
+
+	struct device *dev;
+	struct i2c_client *client;
+
+	struct      input_dev *input;
+
+	struct  tp_device  tp;
+	struct ct36x_ops *ops;
+	void *priv;
+};
+
+static int i2c_master_normal_send(const struct i2c_client *client, const char *buf, int count, int scl_rate)
+{
+        int ret;
+        struct i2c_adapter *adap=client->adapter;
+        struct i2c_msg msg;
+
+        msg.addr = client->addr;
+        msg.flags = client->flags;
+        msg.len = count;
+        msg.buf = (char *)buf;
+        msg.scl_rate = scl_rate;
+        //msg.udelay = client->udelay;
+
+        ret = i2c_transfer(adap, &msg, 1);
+        return (ret == 1) ? count : ret;
+}
+
+static int i2c_master_normal_recv(const struct i2c_client *client, char *buf, int count, int scl_rate)
+{
+        struct i2c_adapter *adap=client->adapter;
+        struct i2c_msg msg;
+        int ret;
+
+        msg.addr = client->addr;
+        msg.flags = client->flags | I2C_M_RD;
+        msg.len = count;
+        msg.buf = (char *)buf;
+        msg.scl_rate = scl_rate;
+        //msg.udelay = client->udelay;
+
+        ret = i2c_transfer(adap, &msg, 1);
+
+        return (ret == 1) ? count : ret;
+}
+EXPORT_SYMBOL(i2c_master_normal_recv);
+
+static inline int ct36x_read(struct ct36x_data *ts, char *buf, int len)
+{
+	return i2c_master_normal_recv(ts->client, buf, len, CT36X_I2C_RATE);
+}
+
+static inline int ct36x_write(struct ct36x_data *ts, char *buf, int len)
+{
+	return i2c_master_normal_send(ts->client, buf, len, CT36X_I2C_RATE);
+}
+
+static inline int ct36x_update_read(struct ct36x_data *ts, unsigned short addr, char *buf, int len)
+{
+	int ret;
+	unsigned short bak = ts->client->addr;
+
+	ts->client->addr = addr;
+	ret = ct36x_read(ts, buf, len);
+	ts->client->addr = bak;
+
+	return ret;
+}
+
+static inline int ct36x_update_write(struct ct36x_data *ts, unsigned short addr, char *buf, int len)
+{
+	int ret;
+	unsigned short bak = ts->client->addr;
+
+	ts->client->addr = addr;
+	ret = ct36x_write(ts, buf, len);
+	ts->client->addr = bak;
+
+	return ret;
+}
+int ct36x_chip_set_idle(struct ct36x_data *ts);
+int ct36x_chip_go_sleep(struct ct36x_data *ts);
+int ct36x_chip_get_binchksum(void);
+int ct36x_chip_get_fwchksum(struct ct36x_data *ts);
+int ct36x_chip_go_bootloader(struct ct36x_data *ts);
+int ct36x_chip_get_fwchksum(struct ct36x_data *ts);
+int ct36x_chip_get_ver(struct ct36x_data *ts);
+
+#endif
diff --git a/drivers/input/touchscreen/ct36x/ct36x_ts.c b/drivers/input/touchscreen/ct36x/ct36x_ts.c
new file mode 100644
index 0000000..4007e72
--- /dev/null
+++ b/drivers/input/touchscreen/ct36x/ct36x_ts.c
@@ -0,0 +1,355 @@
+#include "ct36x_priv.h"
+#include <linux/of_gpio.h>
+#include <linux/async.h>
+
+#include "core.c"
+#include "ct360.c"
+#include "ct363.c"
+
+int inline ct36x_set_ops(struct ct36x_data *ts, int model)
+{
+    switch(model){
+        case 360: ts->ops = &ct360_ops; break;
+        case 363: ts->ops = &ct363_ops; break;
+        case 365: ts->ops = &ct363_ops; break;
+        default: return -EINVAL;
+    };
+
+    return 0;
+}
+
+#ifndef CONFIG_CT36X_TS   //make modules
+static int en = 0;
+module_param(en, int, 0644);
+
+static int model = -1;
+module_param(model, int, 0644);
+
+static int i2c = -1;
+module_param(i2c, int, 0644);
+
+static int addr = -1;
+module_param(addr, int, 0644);
+
+static int x_max = -1;
+module_param(x_max, int, 0644);
+
+static int y_max = -1;
+module_param(y_max, int, 0644);
+
+static int irq = -1;
+module_param(irq, int, 0644);
+
+static int rst = -1;
+module_param(rst, int, 0644);
+
+static int orientation[4] = {1, 0, 1, 0};
+module_param_array(orientation, int, NULL, 0644);
+
+static int ct36x_check_param(void)
+{
+    int i;
+
+    if(en != 1)
+        return -EINVAL;
+    if(model < 0)
+        return -EINVAL;
+    if(i2c < 0)
+        return -EINVAL;
+    if(addr <= 0x00 || addr >=0x80)
+        return -EINVAL;
+    if(x_max <= 0 || y_max <= 0)
+        return -EINVAL;
+    for(i = 0; i < 4; i++) {
+        if(orientation[i] != 0 && orientation[i] != 1 && orientation[i] != -1)
+            return -EINVAL;
+    }
+
+    return 0;
+}
+
+static struct ct36x_platform_data ct36x_pdata;
+
+static struct i2c_board_info __initdata ct36x_info = {
+    .type = CT36X_NAME,
+    .flags = 0,
+    .platform_data = &ct36x_pdata,
+};
+
+static int ct36x_add_client(void)
+{
+    int i;
+    struct port_config ct36x_rst, ct36x_irq;
+
+    ct36x_pdata.model = model;
+    ct36x_pdata.x_max = x_max;
+    ct36x_pdata.y_max = y_max;
+
+    for(i = 0; i < 4; i++)
+        ct36x_pdata.orientation = orientation[i];
+    ct36x_rst = get_port_config(rst);
+    ct36x_pdata.rst_io.gpio = ct36x_rst.gpio;
+    ct36x_pdata.rst_io.active_low = ct36x_rst.io.active_low;
+
+    ct36x_irq = get_port_config(irq);
+    ct36x_pdata.irq_io.gpio = ct36x_rst.gpio;
+    ct36x_pdata.irq_io.active_low = ct36x_rst.io.active_low;
+
+    ct36x_info.addr = addr;
+
+    return i2c_add_device(i2c, &ct36x_info);
+}
+#endif
+
+static irqreturn_t ct36x_irq_handler(int irq, void *data)
+{
+    struct ct36x_data *ts = data;
+    ct36x_dbg(ts, "----------- ct36x_irq_handler -----------\n");
+    if(ts->ops->report)
+        ts->ops->report(ts);
+
+    return IRQ_HANDLED;
+}
+
+
+static void ct36x_ts_early_suspend(struct tp_device *tp_d)
+{
+    struct ct36x_data *ts = container_of(tp_d, struct ct36x_data, tp);
+
+    ct36x_dbg(ts, "<%s> touchscreen suspend\n", CT36X_NAME);
+
+    disable_irq_nosync(ts->irq);
+
+    if(ts->ops->suspend)
+        ts->ops->suspend(ts);
+
+}
+
+static void ct36x_ts_late_resume(struct tp_device *tp_d)
+{
+    struct ct36x_data *ts;
+    ts = container_of(tp_d, struct ct36x_data, tp);
+
+    ct36x_dbg(ts, "<%s> tochscreen resume\n", CT36X_NAME);
+    if(ts->ops->resume)
+        ts->ops->resume(ts);
+
+    enable_irq(ts->irq);
+}
+
+
+static int ct36x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    int orientation[4];
+    int ret = 0, i;
+    struct ct36x_data *ts = NULL;
+    struct device_node *np = client->dev.of_node;
+    enum of_gpio_flags rst_flags;
+    unsigned long irq_flags;
+    u32 val;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        dev_err(&client->dev, "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+        return -ENODEV;
+    }
+
+    ts = devm_kzalloc(&client->dev, sizeof(struct ct36x_data), GFP_KERNEL);
+    if (ts == NULL) {
+        dev_err(&client->dev, "alloc for struct rk_ts_data fail\n");
+        return -ENOMEM;
+    }
+
+    if (!np) {
+        dev_err(&client->dev, "no device tree\n");
+        return -EINVAL;
+    }
+    if (of_property_read_u32(np, "max-x", &val)) {
+        dev_err(&client->dev, "no max-x defined\n");
+        return -EINVAL;
+    }
+    ts->x_max = val;
+    if (of_property_read_u32(np, "max-y", &val)) {
+        dev_err(&client->dev, "no max-y defined\n");
+        return -EINVAL;
+    }
+    ts->y_max = val;
+
+    printk("the ts->x_max is %d,ts->y_max is %d\n",ts->x_max,ts->y_max);
+    if (of_property_read_u32(np, "ct-model", &val)) {
+        dev_err(&client->dev, "no ct-model defined\n");
+        return -EINVAL;
+    }
+    ts->model = val;
+    flag_ct36x_model = ts->model;
+    ts->irq_io.gpio = of_get_named_gpio_flags(np, "touch-gpio", 0, (enum of_gpio_flags *)&irq_flags);
+    ts->rst_io.gpio = of_get_named_gpio_flags(np, "reset-gpio", 0, &rst_flags);
+
+    ret = of_property_read_u32_array(np, "orientation",orientation,4);
+    if (ret < 0)
+        return ret;
+    for(i = 0; i < 4; i++) {
+        ts->orientation[i] = orientation[i];
+    }
+
+    ts->client = client;
+    ts->dev = &client->dev;
+
+    i2c_set_clientdata(client, ts);
+
+    ret = ct36x_set_ops(ts, ts->model);
+    if(ret < 0){
+        dev_err(ts->dev, "Failed to set ct36x ops\n");
+        goto err_ct36x_set_ops;
+    }
+
+    if (gpio_is_valid(ts->rst_io.gpio)) {
+        ts->rst_io.active_low = (rst_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+        ret = devm_gpio_request_one(&client->dev, ts->rst_io.gpio, (rst_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW, "ct363 reset pin");
+        if (ret != 0) {
+            dev_err(&client->dev, "ct363 gpio_request error\n");
+            return -EIO;
+        }
+    } else {
+        dev_info(&client->dev, "reset pin invalid\n");
+    }
+
+    if (gpio_is_valid(ts->irq_io.gpio)) {
+        ts->irq_io.active_low = (irq_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+        ret = devm_gpio_request_one(&client->dev, ts->irq_io.gpio, (irq_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW, "ct363 irq pin");
+        if (ret != 0) {
+            dev_err(&client->dev, "ct363 gpio_request error\n");
+            return -EIO;
+        }
+    }
+
+
+
+    if(ts->ops->init){
+        ret = ts->ops->init(ts);
+        if(ret < 0){
+            dev_err(ts->dev, "Failed to init ct36x chip\n");
+            goto err_ct36x_init_chip;
+        }
+    }
+
+    ts->input = devm_input_allocate_device(&ts->client->dev);
+    if(!ts->input){
+        ret = -ENODEV;
+        dev_err(ts->dev, "Failed to allocate input device\n");
+        goto err_input_allocate_device;
+    }
+
+    ts->input->name = CT36X_NAME;
+    ts->input->dev.parent = &client->dev;
+    set_bit(EV_ABS, ts->input->evbit);
+    set_bit(INPUT_PROP_DIRECT, ts->input->propbit);
+    input_mt_init_slots(ts->input, ts->point_num,0);
+    input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->x_max, 0, 0);
+    input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->y_max, 0, 0);
+    input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(ts->input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+
+    ret = input_register_device(ts->input);
+    if(ret < 0){
+        dev_err(ts->dev, "Failed to register input device\n");
+        goto err_input_register_devcie;
+    }
+
+
+    ts->tp.tp_resume = ct36x_ts_late_resume;
+    ts->tp.tp_suspend = ct36x_ts_early_suspend;
+    tp_register_fb(&ts->tp);
+
+    ts->irq = gpio_to_irq(ts->irq_io.gpio);
+    if (ts->irq)
+    {
+        ret = devm_request_threaded_irq(&client->dev, ts->irq, NULL, ct36x_irq_handler, irq_flags | IRQF_TRIGGER_FALLING | IRQF_ONESHOT, client->name, ts);
+        if (ret != 0) {
+            printk(KERN_ERR "Cannot allocate ts INT!ERRNO:%d\n", ret);
+            goto err_request_threaded_irq;
+        }
+    }
+
+    dev_info(ts->dev, "CT363 Successfully initialized\n");
+    return 0;
+err_request_threaded_irq:
+    tp_unregister_fb(&ts->tp);
+err_input_register_devcie:
+err_input_allocate_device:
+    if(ts->ops->deinit)
+        ts->ops->deinit(ts);
+err_ct36x_init_chip:
+err_ct36x_set_ops:
+    i2c_set_clientdata(client, NULL);
+    return ret;
+}
+
+static int ct36x_ts_remove(struct i2c_client *client)
+{
+    struct ct36x_data *ts = i2c_get_clientdata(client);
+
+    if(ts->ops->deinit)
+        ts->ops->deinit(ts);
+    i2c_set_clientdata(client, NULL);
+
+    return 0;
+}
+
+static const struct i2c_device_id ct36x_ts_id[] = {
+    { CT36X_NAME, 0 },
+    { }
+};
+static struct of_device_id ct36x_ts_dt_ids[] = {
+    { .compatible = "ct,ct36x" },
+    { }
+};
+
+static struct i2c_driver ct36x_ts_driver = {
+    .probe      = ct36x_ts_probe,
+    .remove     = ct36x_ts_remove,
+    .id_table   = ct36x_ts_id,
+    .driver = {
+        .owner	= THIS_MODULE, 
+        .name	= CT36X_NAME,
+        .of_match_table = of_match_ptr(ct36x_ts_dt_ids),
+    },
+};
+
+static void __init ct36x_ts_init_async(void *unused, async_cookie_t cookie)
+{
+#ifndef CONFIG_CT36X_TS   //make modules
+    int ret = 0;
+
+    ret = ct36x_check_param();
+    if(ret < 0){
+        pr_err("<%s> Param error, en: %d, model:%d, i2c: %d, addr: %d, x_max: %d, y_max: %d\n",
+                CT36X_NAME, en, model, i2c, addr, x_max, y_max);
+        return ret;
+    }
+
+    ret = ct36x_add_client();
+    if(ret < 0){
+        pr_err("<%s> Failed to add client, i2c: %d, addr: %d\n", CT36X_NAME, i2c, addr);
+        return ret;
+    }
+#endif
+    i2c_add_driver(&ct36x_ts_driver);
+}
+
+static int __init ct36x_ts_init(void)
+{
+    async_schedule(ct36x_ts_init_async, NULL);
+    return 0;
+}
+
+static void __exit ct36x_ts_exit(void)
+{
+    i2c_del_driver(&ct36x_ts_driver);
+}
+
+module_init(ct36x_ts_init);
+module_exit(ct36x_ts_exit);
+
+MODULE_DESCRIPTION("CT36X Touchscreens Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/tp_suspend.h b/drivers/input/touchscreen/tp_suspend.h
new file mode 100644
index 0000000..68e3d58
--- /dev/null
+++ b/drivers/input/touchscreen/tp_suspend.h
@@ -0,0 +1,79 @@
+/*
+ * TP  suspend Control Abstraction
+ *
+ * Copyright (C) RK Company
+ *
+ */
+#ifndef _RK_TP_SUSPEND_H
+#define _RK_TP_SUSPEND_H
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fb.h>
+#include <linux/notifier.h>
+
+struct  tp_device{
+	struct notifier_block fb_notif;
+	int(*tp_suspend)(struct  tp_device*);
+	int(*tp_resume)(struct  tp_device*);
+	struct mutex ops_lock;
+};
+
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long action, void *data)
+{
+	struct tp_device *tp;
+	struct fb_event *event = data;
+	int blank_mode = *((int *)event->data);
+	int ret = 0;
+
+	tp = container_of(self, struct tp_device, fb_notif);
+
+	//printk("%s.....lin=%d tp->status=%x,blank_mode=%x\n",__func__,__LINE__,tp->status,blank_mode);
+
+	mutex_lock(&tp->ops_lock);
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (blank_mode) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			ret = tp->tp_suspend(tp);
+			break;
+		}
+	}
+	else if (action == FB_EVENT_BLANK) {
+		switch (blank_mode) {
+		case FB_BLANK_UNBLANK:
+			tp->tp_resume(tp);
+			break;
+		default:
+			break;
+		}
+	}
+	mutex_unlock(&tp->ops_lock);
+
+	if (ret < 0)
+	{
+		printk("TP_notifier_callback error action=%x,blank_mode=%x\n",(int)action,blank_mode);
+		return ret;
+	}
+
+	return NOTIFY_OK;
+}
+
+static int tp_register_fb(struct tp_device *tp)
+{
+	memset(&tp->fb_notif, 0, sizeof(tp->fb_notif));
+	tp->fb_notif.notifier_call = fb_notifier_callback;
+	mutex_init(&tp->ops_lock);
+
+	return fb_register_client(&tp->fb_notif);
+}
+
+static void tp_unregister_fb(struct tp_device *tp)
+{
+	fb_unregister_client(&tp->fb_notif);
+}
+#endif
diff --git a/include/linux/ct36x.h b/include/linux/ct36x.h
new file mode 100644
index 0000000..c3121dd
--- /dev/null
+++ b/include/linux/ct36x.h
@@ -0,0 +1,23 @@
+#ifndef __LINUX_CT36X__
+#define __LINUX_CT36X__
+
+#define CT36X_NAME	"ct36x_ts"
+
+struct ct36x_gpio{
+	int gpio;
+	int active_low;
+};
+
+struct ct36x_platform_data{
+	int model;
+
+	int x_max;
+	int y_max;
+	
+	struct ct36x_gpio rst_io;
+	struct ct36x_gpio irq_io;
+
+	int orientation[4];
+};
+
+#endif
diff --git a/include/uapi/linux/i2c.h b/include/uapi/linux/i2c.h
index 0e949cb..897304d 100644
--- a/include/uapi/linux/i2c.h
+++ b/include/uapi/linux/i2c.h
@@ -78,6 +78,7 @@ struct i2c_msg {
 #define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
+	__u32 scl_rate;		/* add by kfx */
 };
 
 /* To determine what functionality is present */
